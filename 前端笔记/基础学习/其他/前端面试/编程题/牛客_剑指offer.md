#### 1. 解题思路

1. 数组方法:slice, splice, join; 字符串方法:slice, split；Math；用 a[变量] 的方式读取对象属性
2. &运算符：将数字变成32位2进制，然后每位相与并返回结果，通常与 << 等位运算配合使用
3. 快慢指针：解决绕圈问题；快指针以两倍慢指针速度移动，必相交
4. 层序遍历：使用队列的方式，每次弹出队列头，并将不为空的左右节点加入队列
5. 候选法：解决众数（超过一半）问题；消去两个不相等的数；相等就加一，不相等就减一，为0就换候选人
6. 贪心算法：解决连续子数组最大和问题；前面和为负，则对后面的结果不作贡献，因此可以舍掉
7. 二分法：left=mid-1; rigth=mid+1;通过left<=right判断是否继续循环
8. 使用sort对数组进行排序时，默认会以Unicode编码排序，所以11会在2的前面，arr.sort((a,b)=> a-b)
9. 二维数组的二分查找：以右上角或者左下角为起点进行判断，进行一列或一行的排除，缩小范围
10. 给定前序及中序遍历序列，要求重建二叉树：前序数组第一个元素就是根节点，可区分中序数组的左右树，利用递归的方式，每次传进左或右树的前中序数组；注意：if([])  空数组也是true
11. 给定一个数n，求在n=a1+a2+a3+...+am条件下，s=a1 x a2 x a3 x...x am最大：尽量让3的个数多即为最大
12. 求数组最大值方法：Math.max(...a)  ...a是拓展运算符；reduce, sort

13. slice不会改变原数组，但splice会，而且splice(start,number,new...)新插入的元素是从start的位置开始插入的,而其原本的元素则会排在新插入元素的后面（number为0时的情况）；Set可以自动去重











#### 2. 算法代码

##### 2.1. 二叉树的中序遍历

```javascript
    while (curr || stack.length != 0) {
      while (curr) {
        stack.unshift(curr)
        curr = curr.left
      }
      curr = stack[0]
      console.log(curr.val)
      stack.shift()
      curr = curr.right
    }
```

