#### 1. 数组方法

| 方法                       | 作用                                                         |
| -------------------------- | ------------------------------------------------------------ |
| push()                     | 将一个或多个元素添加到数组的末尾，并返回该数组的新长度       |
| unshift()                  | 将一个或多个元素添加到数组的开头，并返回该数组的新长度       |
| pop()                      | 从数组中删除最后一个元素，并返回该元素的值                   |
| shift()                    | 从数组中删除第一个元素，并返回该元素的值                     |
| splice(下标, 个数, 新元素) | 删除指定的元素，并允许向该位置添加新的元素（可多个，==数组的话需要用展开运算符 `...` 将其展开==）；注意个数为0时，新元素会排在原下标元素的前面 |
| sort()                     | 排序，会影响原数组；==默认是按 unicode 编码排序，会造成 11 比 2 小的情况==，解决办法：`arr.sort((a,b)=>{ return a-b })` （升序） |
| Array(size).fill()         | 创建并填充指定大小的数组；`Array(5).fill(0) //[0, 0, 0, 0, 0]` |
| join()                     | 用于把数组中的所有元素转换成一个字符串，参数为每个元素之间的分隔符，默认为 `,` ，可以是空字符串 `''` 表示没有间隔 |
| map()                      | 可以遍历数组处理数据，并返回新数组：`const newArr = arr.map((ele,index)=>{return ele+'_new'})` |
| forEach()                  | 遍历数组（适合遍历数组对象），无返回值：`arr.forEach((item, index) => { console.log(item) })` |
| filter()                   | 过滤数组，筛选符合条件的数组元素，`const arr2 = arr.filter(item => item > 3);` |
| reduce()                   | 累计器，返回累计处理的结果，经常用于求和等：`arr.reduce((上一次值, 当前值)=>{}, 初始值)`，如：`arr.reduce((a, b) => { return a + b }, 0)` |
| find()                     | 返回符合条件的第一个元素值：`arr.find(item => item.name === '小米')` |
| every(), some()            | 检测数组中的元素是否符合条件，前者要所有元素都满足才返回 true ，后者只要有一个满足就返回 true |
| concat(), reverse()        | 合并数组，并返回新数组；反转数组                             |
| Array.from()               | 可将伪数组转换为真数组                                       |
|                            |                                                              |



#### 2. 字符串方法

| 方法                  | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| split()               | 可将字符串拆分成数组，参数为字符串的分隔符                   |
| substring(开始, 结束) | 截取字符串，左闭右开，不写结束索引表示截取到最后；类似的还有 substr(开始，数量)，但已废弃 |
| startsWith()          | 检测是否以某字符串开头，第二个参数可指定检测开始位置；类似的还有 endsWith() |
| includes()            | 判断一个字符串是否包含在另一个字符串中，返回布尔值           |
| indexOf()             | 检测是否包含某字符串，返回索引，没有则返回 -1                |
| replace()             | 替换字符串，支持正则匹配                                     |
| match()               | 查找字符串，支持正则匹配，返回数组                           |
| toUpperCase()         | 用于将字母转为大写；toLowerCase() 转小写                     |
| trim()                | 去除字符串左右两侧的空格                                     |
|                       |                                                              |
|                       |                                                              |

字符串和数组有些方法是互通的，可尝试使用



#### 3. 对象方法

| 方法            | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| Object.keys()   | 获取对象中的所有属性名，返回一个数组：`const arr = Object.keys(obj)` |
| Object.values() | 获取所有属性值                                               |
| Object.assign() | 合并对象，常用于对象拷贝：`Object.assign(obj2, obj1)` 将 obj1 拷贝给 obj2 |
|                 |                                                              |
|                 |                                                              |
|                 |                                                              |





#### 4.  this 的指向

- 自调用函数的this指向 window 
- 箭头函数的 this 是继承外面环境的 this ，跟谁调用无关
- 普通函数调用（直接调用），this 一定指向全局对象 window ，不论函数在哪儿，不论函数在哪儿调用
- 对象函数调用，构造函数调用，apply，call；谁调用就指向谁
- 定时器回调函数的 this 默认指向的是 window ，可以用箭头函数让其指向父级的 this 

简单来讲就是谁调用指向谁，箭头函数沿用外层函数 this ，其他为 window 

| 函数       | 作用与区别                                                   |
| ---------- | ------------------------------------------------------------ |
| call()     | `fn.call(thisArg, arg1, arg2)` ，调用函数并指定函数中 this 的值 |
| apply()    | `fn.apply(thisArg, [arg1, arg2])` ，作用和 call 一样但函数的参数需放在数组中 |
| ==bind()== | `let newfn = fn.bind(thisArg, arg1, arg2)` ，不调用函数，只改变函数 this 指向并返回新函数 |

