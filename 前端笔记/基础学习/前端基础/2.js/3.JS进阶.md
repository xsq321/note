高级语法：比如  JS 新增语法，高级技巧等等



#### 1. 作用域链

本质上是底层的变量查找机制

在函数被执行时，会优先查找当前函数作用域，找不到则依次逐级查找父级作用域（就近原则）；==只和函数声明的位置有关，跟函数的调用者和在哪儿调用无关==



#### 2. 垃圾回收机制

栈：由操作系统自动分配释放函数的参数值、局部变量等。基本数据类型放到栈里面

堆：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面

常见浏览器垃圾回收算法：引用计数法和标记清除法

##### 2.1. 引用计数（基本废弃）

IE 采用的引用计数算法，定义为“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用就回收

算法：跟踪记录被引用的次数，被引用（有地址指向它）就加1，减少（一般采用赋值为 null 的方式）引用就减1，为0则释放内存；但存在问题，当两个对象互相引用时，引用次数无法归零，导致内存泄漏

##### 2.2. 标记清除法

定义为“无法达到的对象”，就是从根部（在js中就是全局对象）出发定时扫描内存中的对象，扫描不到的被标记为不再使用，稍后回收



#### 3. 闭包

概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

简单理解：闭包 = 内层函数 + 外层函数的变量 （内层函数使用了外层函数的变量）

作用：封闭数据，提供操作，==使外部也可以访问函数内部的变量==

```js
function outer() {
    let i = 1
    function fn() {
        return i
    }
    return fn
}
const fun = outer()
let x = fun() // 函数的外部拿到了函数内的局部变量
```

应用：实现数据的私有；比如可用于统计函数的调用次数（全局变量的话会被随意修改，通过闭包就可实现私有）

闭包存在内存泄漏



#### 4. 解构赋值

```js
// 数组解构
const [max, min, avg] = [100, 60, 80]
[b, a] = [a, b]	//典型应用，交换两个变量的值；注意：该代码的前面需加个分号，用于和上一行代码分开
const [a, , c, d] = [1, 2, 3, 4]	// 按需导入，可忽略某些值
const [a, b, [c, d]] = [1, 2, [3, 4]];	// 多维数组的解构

// 对象解构
const { uname, age } = { uname: "xiaoming", age: 18 }	// 注意变量名和属性名得相同
const { uname: username, age } = { uname: "xiaoming", age: 18 }	// 修改变量名
const { uname: { name } } = { uname: { name: "xiaoming" } }	// 多级对象解构

// 数组对象解构
const arr = [{ uname: "xiaoming", age: 18 }, { uname: "xiaohong", age: 19 }];
const [{ uname: uname1, age: age1 }, { uname: uname2, age: age2 }] = arr;
```



#### 5. 构造函数

是一种特殊的函数，主要用来初始化对象；可通过构造函数快速创建多个类似的对象

##### 5.1. new 实例化执行过程

==new 会创建一个新空对象，同时使构造函数中的 this 指向这个空对象，然后传入参数执行构造函数代码，最后返回这个对象（实例对象）==

##### 5.2. 实例成员&静态成员

实例对象中的属性和方法称为实例成员；==构造函数的属性和方法被称为静态成员，静态成员只能通过构造函数访问==，如 Date.now(), Math.PI, Math.random()

```js
function Person(name, age){
  this.name = name
  this.age = age
  this.sing = function(){ console.log('唱歌') }
} // name和age就是实例属性，sing就是实例方法
Person.eyes = 2	// 静态属性
Person.walk = function(){} //静态方法，this指向构造函数
const person = new Person("xiaoming", 18);
```

##### 5.3. 内置构造函数

基本包装类型：字符串、数值、布尔等基本数据类型都有专门的构造函数，这些我们称为包装类型；String, Number, Boolean 等

引用类型：Object, Array, RegExp, Date 等

拓展：number.toFixed(2) 表示保留两位小数，且四舍五入

##### 5.4. js 的面向对象

面向对象三大特性：封装、继承、多态；js 通过构造函数实现封装，通过原型实现继承



#### 6. 原型

##### 6.1. 原型对象

每个构造函数都有 prototype 属性，指向它的原型对象

构造函数会存在浪费内存的问题，如上面的实例方法 sing ，每 new 一个实例都会单独开辟内存存放这个函数。而把这个方法放到原型对象上就可以解决这个问题（利用原型对象实现方法共享）

```js
Person.prototype.sing = function () { console.log(this.name + "正在唱歌") };
```

构造函数和原型对象中的 this 都指向实例对象

每个原型对象都有 constructor 属性，指向构造函数，即 `Person.prototype.constructor === Person` 

##### 6.2. 对象原型

每个实例对象都有 `__proto__` 属性，指向构造函数的原型，即 `person.__proto__ === Person.prototype`

`__proto__` 是 js 非标准属性，在浏览器控制台中一般显示为 `[[prototype]]` ，但本质是相同的

通过实例对象得到它的构造函数：`person.__proto__.constructor === Person`

##### 6.3. 原型继承

```js
Woman.prototype = Person
Woman.prototype.constructor = W
```







