## 一、概念
Fiber 是一个基于优先级策略和帧间回调的循环任务调度算法的架构方案。随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一棵组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。
解决方法：当遇到进程同步阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。而 React Fiber 便是为了实现任务分割而诞生的。
Fiber 架构的核心思想就是 任务拆分 和 协同，主动把执行权交给主线程，使主线程有时间空档处理其他高优先级任务

## 二、架构背景
浏览器的渲染引擎是单线程，它将 GUI 描绘、时间器处理、事件处理、JavaScript 执行、远程资源加载通通放在一起。当做某件事，只有将它做完才能做下一件事。如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化，一些 DOM 操作，内部也会对 Reflow（重绘）进行处理。 Reflow 是一个性能黑洞，很可能让页面的大多数元素进行重新布局。
**解决思路**
把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候再继续执行。这种策略叫做 Cooperative Scheduling（合作式调度），操作系统常用任务调度策略之一。
那么如何拆分成子任务？一个子任务多大合适？怎么判断是否还有剩余时间？有剩余时间怎么去调度应该执行哪个任务？没有剩余时间之前的任务怎么办？接下来整个 Fiber 架构就是来解决这些问题的。

## 三、Fiber 是如何工作的？
1、ReactDOM.render() 和 setState 的时候开始创建更新
2、将创建的更新加入任务队列，等待调度
3、在 requestIdleCallback 空闲时执行任务
4、从根节点开始遍历 Fiber Node，并且构建 WorkInProgress Tree
5、生成 EffectList
6、根据 EffectList 更新 DOM

## 四、总结
React Fiber 是对 React 来说是一次革命，解决了 React 项目 严重依赖于手工优化 的痛点，通过系统级别的时间调度，实现划时代的性能优化。鬼才般的 Fiber 结构，为异常边界提供了退路，也为限量更新提供了下一个起点。
**React Fiber 最终提供的关键特性主要是：**
增量渲染（把渲染任务拆分成块，均匀分布到多帧）
更新时能够暂停、终止、复用渲染任务
给不同类型的更新赋予优先级
并发方面新的基础能力
增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做 cooperative scheduling（合作式调度），操作系统的 3 种任务调度策略之一（Firefox 还对真实 DOM 应用了这项技术）。
另外，React 自身的 killer feature 是 Virtual DOM，两个原因：
Coding UI 变简单了（不用关心浏览器应该怎么做，而是把下一刻的 UI 描述给 React 听）
既然 DOM 能 Virtued，别的（硬件、VR、Native APP）也能

