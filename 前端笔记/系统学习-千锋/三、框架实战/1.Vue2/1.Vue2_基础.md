##### 1. 传入参数的同时传入事件对象

```html
<button @click="fn(1,$event)">按钮</button>	// 不传入参数时会默认传入事件对象
```

注意在标签中事件对象需写成 $event 

##### 2. v-for 的 key

列表渲染一定要绑定 key ，主要用在 Vue 的虚拟 DOM 对比算法，能让列表中的节点得到复用；尽量不要用下标，用后台数据提供的唯一标识

##### 3. 虚拟 DOM

是真实 DOM 的映射，即用 js 对象（有 tagName, props, children 等属性，分别代表标签名、该 dom 节点的属性和该节点的子节点）来描述真实 DOM 节点，本质上就是在 js 和 DOM 之间做了一个缓存

##### 4. v-model 实现双向绑定原理

通过 v-bind 动态绑定 value 属性，然后通过监听 input 事件把变化后的值赋给变量

v-model 是一个语法糖：:value + @input 

##### 5. Object.defineProperty()

Vue 中很多地方都用到了它，比如数据劫持、数据代理、计算属性等；

可以为对象添加或修改属性实现数据代理，如果是给对象自己添加（自己代理自己）则可以使之变为响应式的

```js
Object.defineProperty(vm,'name',{ get(){}, set(value){} })
```

访问时调用 get 方法，修改时调用 set 方法

Vue 的数据绑定的原理是由数据劫持结合订阅发布模式实现的；页面订阅，在 getter 里面进行依赖收集（是个数组，存放着使用该数据的位置），在 setter 里面发布更新并通过依赖通知页面相应位置进行修改

##### ==6. 数据双向绑定完整过程==

- Vue 通过 Object.defineProperty() 方法使 vm 对象代理了 data 对象中的属性；

- 页面通过 v-bind 绑定数据时就是访问 vm 的属性，访问触发了 get 函数，返回 data 对象中的值的同时进行依赖收集；

- 而修改数据则是页面通过触发事件，在事件回调函数中对 vm 的数据进行修改，修改触发了 set 函数，==在 set 函数中修改 data 数据的值并通过依赖通知页面相应位置重新渲染==，重新渲染即重新访问 vm 的属性，又触发 get 函数得到修改后的 data 数据

##### 7. 对象&数组的更新检测

vue 会监视 data 中对象的所有层级的数据，但不会监视后面为对象新添加的属性，所以向对象添加新属性需要使用 this.$set() ，删除用 this.$delete() ，也就是说只有修改已存在的对象属性才会被监听。

数组因为有次序（索引容易变）不适合用 Object.defineProperty 实现数据代理，也就是说 vue 并没有监视数组内部的数据，所以通过索引直接赋值修改并不会被监听（不是响应式的）；

所以数组的修改需要使用会改变原数组的那些方法（ push, pop, shift, unshift, splice, sort, reverse ，其实 vue 对这些方法进行了封装（重写），就是添加了通知页面更新的代码），而 filter 等不会影响原数组的方法要将改变之后的新数组替换掉原来的旧数组实现页面更新







#### 补充：Less 

```js
npm i less	// 下载less
lessc index.less ./index.css	// 控制台编译less到指定位置
@width: 10px + 20px;	// @代表变量,可直接计算
@{box} { @{bgc}: url("@{url}/1.jpg"); }	// @{} 可在选择器、属性名和属性值中使用变量
@bg();	// bg是个变量，里面的值为样式对象，@bg()就可以使用该对象里的所有样式，类似混合
.box2 { .box1(); }		// 混合，可在样式内部直接使用已定义的样式
@import url('')		// 引入外部样式
```

安装 esay less 插件后，保存 less 文件时会在同文件夹下自动创建同名的 .css 文件

嵌套语法：就是可以嵌套使用选择器，可搭配父选择器 & 使用，非常方便且层级关系清晰；和 scss 用法相同



