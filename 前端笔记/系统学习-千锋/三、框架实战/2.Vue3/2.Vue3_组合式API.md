#### 1. 选项 API 和组合 API 

选项式 API ：使用包含多个选项的对象来描述组件的逻辑，如 data, methods, mounted 等

组合式 API ：使用导入的 API 函数来描述组件逻辑

```vue
<template>
  <h3>Vue3计数器</h3>
  <p>Count:{{ count }}</p>
  <button @click="addHandler">增加</button>
</template>
<script setup>
  import { ref } from "vue"
  const count = ref(0)
  const addHandler = () =>{
    count.value++
  }
</script>
```



#### 2. Vue3 响应式

```vue
<template>
  <div>num: {{ num }}</div>
  <p><button @click="changeNum">num++</button></p>
</template>

<script>
import { ref } from 'vue'
export default {
  props: ['info'],
  emits:['say'],
  setup(props, context) {
    let num = ref(1)
    const changeNum = () => {
      num.value++
    }
    return { num, changeNum }
  }
}
</script>
```

##### 2.1. setup

Vue3 中一个新的配置项，是一个专门用于组合式 API 的==特殊钩子函数== ，所有的组合 API 函数都在此使用，组件中用到的数据、方法等都要写在 setup 中 ，返回一个对象（暴露数据）；在 beforeCreate 生命周期之前执行（组件对象还没有创建），所以在 setup 内无法使用 this 获取组件实例（事实上 setup 函数中根本没有 this ）；

其他生命周期能使用 this 是因为 vue 内部将它们的 this 指向了组件实例，而 setup 是在组件实例化之前执行的所以无法将 this 指向为组件实例。

尽量不与 Vue2 配置（data, methods 等）混用；可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行；如果有重名 setup 的优先

可以接受两个参数：setup(props, context) / setup(props, {attrs, emit, slots}) ；Vue3 中父向子传递方法时也需要接收了，用 emits 接收，和 props 类似，一个接收方法一个接收属性

简写方式：`<script setup>` ，内部只写 Vue3 代码；默认会暴露所有定义的变量？

##### 2.2. ref

```js
let num = ref(1)
```

定义一个数据（一般是基本数据类型）的响应式；内部依然是通过 Object.defineProperty() 的 getter 和 setter 实现的响应式

创建一个包含响应式数据的==引用对象==（ `RefImpl` 对象 ），js 中操作数据需用 num.value ，模板中可直接用 num 

ref 也可以用来定义对象或数组（但一般不用），内部会自动通过 reactive 转为代理对象（ `Proxy` 对象）

##### 2.3. reactive

```js
let obj = reactive({ name: 'xx', age: 18 })
```

定义一个对象类型的响应式数据，不能定义基本数据类型；内部是基于 ES6 的 Proxy 实现的，通过代理对象对源对象进行加工操作

返回一个响应式==代理对象==（ `Proxy` 对象），操作数据可直接使用 obj.name 

定义的响应式数据是“深层的”（递归深度响应式），会影响对象内部所有嵌套的属性，如果有属性值为对象则也会被处理成 Proxy 对象以实现响应式；包括数组（返回的依然是一个对象，只不过 key 值是数字 0, 1, 2... ，使用时既可以 obj[0] 也可以 obj['0'] ），和 Vue2 不同，通过 reactive 代理的数组通过索引直接赋值也可以被监听

##### 2.4. toRef() & toRefs()

`let name = toRef(obj, "name")` 可以将==响应式对象==中某个基本数据类型属性转为单独响应式数据，并且跟源属性的值是相互关联的；操作数据需用 name.value 。对于对象数据类型属性直接赋值即为响应式的： `let hobby = obj.hobby ` ，因为 obj.hobby 将被处理成 Proxy 对象，当然依然可以用 toRef ，从而统一管理属性；

`const obj2 = toRefs(obj)` 可以将响应式对象中所有属性转为单独响应式数据；操作数据用 obj2.name.value

##### 2.5. 响应式原理

通过 Proxy（代理）：拦截对 data 任意属性的任意操作，包括属性值的读写、属性的添加、属性的删除等；解决了 Vue2 中向对象添加、删除属性以及数组索引修改时页面不更新的问题

通过 Reflect（反射）：动态对源对象的相应属性进行特定的操作；暂未发现与直接操作属性的区别

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect

```js
// 被代理
const data = {
  name: 'lucy',
  age: 19,
}
// proxyData 代理对象
const proxyData = new Proxy(data, {
  // 拦截读取属性值
  get(target, prop) {
    // 进行依赖
    return Reflect.get(target, prop)
  },
  // 拦截设置属性值或添加新属性
  set(target, prop, value) {
    // 这里会有修改页面的一些逻辑，即通知页面相应位置进行更新
    return Reflect.set(target, prop, value)
  },
  // 拦截删除属性
  deleteProperty(target, prop) {
    // 这里会有修改页面的一些逻辑，即通知页面相应位置进行更新
    return Reflect.deleteProperty(target, prop)
  },
  // 其他拦截类似，总共拦截了13种操作
})

proxyData.name = 'tom'
```



#### 3. 计算属性

```js
// 完整写法
user.fullname = computed({
  get() { return user.firstname + "-" + user.lastname; },
  set(val) {},
});
// 简写，只读不修改
user.fullname = computed(() => { return 'xxx' })
```

提取到单独文件：新建 utils 文件夹，下建 computed.js 文件，然后按需引入即可；若计算属性很多还可继续细分

```js
import { computed } from 'vue'

export function infoComputed(data) {
  const reverseData = computed(() => {
    return data.value.split('').reverse().join('')
  })
  return reverseData
}
```



#### 4. 侦听器

##### 4.1. 监听 ref 定义的数据

```js
const name = ref('ss')
watch(name, (newVal, oldVal) => {
    console.log(newVal, oldVal)
  }, { immediate: true, deep: true }
)
```

总共三个参数：监听的数据（可写成数组，表示同时监听多个数据做同一逻辑），回调函数，监听的配置

##### 4.2. 监听 reactive 定义的数据

















