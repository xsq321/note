#### 1. 选项 API 和组合 API 

选项式 API ：使用包含多个选项的对象来描述组件的逻辑，如 data, methods, mounted 等

组合式 API ：使用导入的 API 函数来描述组件逻辑（其实就是用函数封装数据与方法等，一个函数代表一个功能）；（==疑问：不同函数共用数据问题？==）

```vue
<template>
  <h3>Vue3计数器</h3>
  <p>Count:{{ count }}</p>
  <button @click="addHandler">增加</button>
</template>
<script setup>
  import { ref } from "vue"
  const count = ref(0)
  const addHandler = () =>{
    count.value++
  }
</script>
```



#### 2. Vue3 响应式

```vue
<template>
  <div>num: {{ num }}</div>
  <p><button @click="changeNum">num++</button></p>
</template>

<script>
import { ref } from 'vue'
export default {
  setup() {
    let num = ref(1)
    const changeNum = () => {
      num.value++
    }
    return { num, changeNum }
  }
}
</script>
```

##### 2.1. setup

Vue3 中一个新的配置项，是一个专门用于组合式 API 的==特殊钩子函数== ，所有的组合 API 函数都在此使用，组件中用到的数据、方法等都要写在 setup 中 ，返回一个对象（暴露数据）；在 beforeCreate 生命周期之前执行，所以在 setup 内无法使用 this 获取组件实例（事实上 setup 函数中根本没有 this ）；

其他生命周期能使用 this 是因为 vue 内部将它们的 this 指向了组件实例，而 setup 是在组件实例化之前执行的所以无法将 this 指向为组件实例。

尽量不与 Vue2 配置（data, methods 等）混用；可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行；如果有重名 setup 的优先

##### 2.2. ref

```js
let num = ref(1)
```

定义一个数据（一般是基本数据类型）的响应式；内部依然是通过 Object.defineProperty() 的 getter 和 setter 实现的响应式

创建一个包含响应式数据的==引用对象==（ `RefImpl` 对象 ），js 中操作数据需用 num.value ，模板中可直接用 num 

ref 也可以用来定义对象或数组（但一般不用），内部会自动通过 reactive 转为代理对象（ `Proxy` 对象）

##### 2.3. reactive

```js
let obj = reactive({ name: 'xx', age: 18 })
```

定义一个对象类型的响应式数据，不能定义基本数据类型；内部是基于 ES6 的 Proxy 实现的，通过代理对象对源对象进行加工操作

返回一个响应式==代理对象==（ `Proxy` 对象），操作数据可直接使用 obj.name 

定义的响应式数据是“深层的”，会影响对象内部所有嵌套的属性；包括数组（返回的依然是一个对象，只不过 key 值是数字 0, 1, 2... ，使用时既可以 obj[0] 也可以 obj['0'] ），和 Vue2 不同，通过 reactive 代理的数组通过索引直接赋值也可以被监听

##### 2.4. toRef() & toRefs()

`let name = toRef(obj, "name")` 可以将==响应式对象==中某个基本数据类型属性转为单独响应式数据，并且跟源属性的值是相互关联的；操作数据需用 name.value 。对于对象数据类型属性直接赋值即为响应式的： `let hobby = obj.hobby ` ，因为 obj.hobby 是一个 Proxy 对象，当然依然可以用 toRef ，从而统一管理属性

`const obj2 = toRefs(obj)` 可以将响应式对象中所有属性转为单独响应式数据；操作数据用 obj2.name.value

##### 2.5. 响应式原理

通过 Proxy（代理）：拦截对 data 任意属性的任意操作，包括属性值的读写、属性的添加、属性的删除等；解决了 Vue2 中向对象添加、删除属性以及数组索引修改时页面不更新的问题

通过 Reflect（反射）：动态对源对象的相应属性进行特定的操作

```js
// 被代理
const data = {
  name: 'lucy',
  age: 19,
}
// proxyData 代理对象
const proxyData = new Proxy(data, {
  // 拦截读取属性值
  get(target, prop) {
    return Reflect.get(target, prop)
  },
  // 拦截设置属性值或添加新属性
  set(target, prop, value) {
    // 这里会有修改页面的一些逻辑，即通知页面更新
    return Reflect.set(target, prop, value)
  },
  // 拦截删除属性
  deleteProperty(target, prop) {
    // 这里会有修改页面的一些逻辑，即通知页面更新
    return Reflect.deleteProperty(target, prop)
  },
  // 其他拦截类似，总共拦截了13种操作
})

proxyData.name = 'tom'
```













