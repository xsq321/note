#### 1. Object.defineProperty

对象自定义属性

```js
Object.defineProperty(obj, "a", {
    configurable: true, // 是否可被删除
    enumerable: true, // 是否可枚举
    writable: true, // 是否可被修改，以上三个默认都为 false
    value: "hello",  // 默认为 undefined
  	// 以下两个属性可用于数据代理，但不可以和上述属性同时使用
  	get(),  // 读取 obj.a 时触发，返回值即是 obj.a 的值
    set(),  // 修改 obj.a 时触发
});
```

数据代理示例（数据驱动视图）：

```html
<div>count: 1</div>
<button>count++</button>
<script>
  const data = {
    count: 1,
  };
  const vm = {};
  Object.defineProperty(vm, "count", {
    get() {
      return data.count;
    },
    set(val) {
      console.log("修改了数据");
      document.querySelector("div").innerHTML = `<div>count: ${val}</div>`; // 更新视图
      data.count = val;
    },
  });
  document.querySelector("button").addEventListener("click", () => {
    vm.count++;  // 每次修改数据都会自动更新页面
  });
</script>
```



#### 2. Proxy 拦截器

```js
const data = {
  count: 1
}
const proxyData = new Proxy(data, {
  get(target, prop) {
    // 可进行一些操作
    return Reflect.get(target, prop)  // 等同于 target[prop] ，只是为了统一操作方式
  },
  set(target, prop, value) {
    return Reflect.set(target, prop, value)  // 修改成功则返回 true 
  },
  deleteProperty(target, prop) {
    return Reflect.deleteProperty(target, prop)
  },
  // 其他拦截类似，总共可拦截13种操作，和 Reflect 一一对应
  apply(target, thisArg, arguments){  // 拦截函数的调用（当代理对象为函数对象时）
    return Reflect.apply(target, thisArg, arguments)
  }
})

proxyData.count = 2
```

其中 Reflect 统一了对对象的各种操作，Reflect 详情：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect



#### 3. Promise 

##### 3.1. 基本使用

```js
const p = new Promise((resolve, reject) => {
  if (true) resolve("成功");
  else reject("失败");
});
p.then((res) => {
  console.log(res);
}).catch((err) => {
  console.log(err);
}).finally(() => {
  console.log("结束");
});
```

.then 后面还可以继续跟 .then ，成功与否取决于上一个 .then 的回调函数，如果上一个回调函数的返回值不是一个 Promise ，则默认返回成功，如果是 Promise 则根据它的返回来确定是否执行后面的 .then

##### 3.2. 静态方法

文档地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise

`Promise.all([p1, p2, p3])` ：等待所有传入的 promise 成功之后才返回成功，否则返回失败

`Promise.race([p1, p2, p3]).then().catch()` ：哪个返回快就使用哪个 Promise 的状态



#### 4. async & await 

可用于优化 Promise 的写法，将异步转为同步（其实本质上还是异步，只是写法上的不同）

```js
const p = new Promise((resolve, reject) => {
  if (false) resolve("p成功");
  else reject("p失败");
});
const fn1 = async function () {  // async 定义的函数的返回值将会是一个 promise 对象
  console.log(1);
  let data = await p;  // 等待 Promise 返回成功才执行 async 函数内后面的异步代码，失败的话直接跳出函数并将 p 的失败状态返回的值作为 fn1() 失败的返回值
  console.log(data);
  console.log(2);
  return "fn1成功";  // 函数的返回值就是 fn1() 成功之后返回的值(供 .then 获取)
};
fn1().then((res) => console.log(res)).catch((err) => console.log(err));
console.log(3);
```

async 定义的函数的返回值将会是一个 promise 对象，所以可使用 .then 与 .catch 处理成功与失败的逻辑；当然依旧可以继续使用 async await 处理，不过需要结合 try catch 用于捕获失败状态，如上面的 fn1() 调用可改为：

```js
const fn2 = async function () {
  try {
    let data = await fn1();  // fn1() 返回失败状态则直接跳到 catch 
    console.log(data);
  } catch (err) {
    console.log("错误信息：", err);
  }
};
fn2();  // 有需要还可继续使用 async await
```



