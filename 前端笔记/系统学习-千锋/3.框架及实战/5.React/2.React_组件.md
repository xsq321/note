#### 1. 组件传值 props

##### 1.1. 父向子传值

父组件可直接在子组件标签上写属性即可，在子组件中通过 this.props 即可获得

##### 1.2. 子向父传值

父组件传递一个函数给子组件，子组件通过 this.props.getVal(val) 调用函数并传递参数，注意父组件传递的函数需要是一个箭头函数，否则 this 会指向 this.props 这个对象而不是父组件实例了

```jsx
<Son getVal={this.getVal}></Son>  // 需把 getVal 写成箭头函数形式（不推荐）
<Son getVal={(val) => this.getVal(val)}></Son>  // 推荐，传的时候就传一个箭头函数，getVal 就可以正常写了，和 onClick 等事件处理 this 指向问题类似
```

##### 1.3. 组件嵌套

和插槽类似，父组件可直接在子组件标签中写内容，子组件可通过 this.props.children 获取并展示

```jsx
// 父组件
<Son num={this.state.num} getVal={(val) => this.getVal(val)}>
  <div>插槽内容</div>
  <div>插槽内容2</div>
</Son>

// 子组件
<div>子组件通过props获得num：{this.props.num}</div>
<button onClick={() => this.props.getVal(this.state.val)}>传递数据给父组件</button>
<div>{this.props.children}</div>  // 展示父向子传递的标签，甚至可通过数组下标控制展示的内容
```



#### 2. 受控组件（表单数据的双向绑定）

由 React 控制的输入表单元素而改变其值的方式，称为受控组件；比如，给表单元素 input 绑定一个 onChange 事件，当 input 状态发生变化时就会触发 onChange 事件，从而更新组件的 state 

受控组件其实就是实现表单数据的双向绑定，不同于 vue，react 实现数据的双向绑定比较原始

```jsx
<input type="text" value={this.state.val} onChange={(e) => this.changeVal(e)} />
```



#### 3. ReactDOM.createPortal()

Portal 提供了一种将子节点渲染到存在于父组件以外 DOM 节点的方案。和 vue3 的新增组件 Teleport 类似，一般用于弹窗、悬浮卡、加载动画等

ReactDOM.createPortal() 的第一个参数是任何可渲染的 React 子元素，例如一个元素，字符串或 react 组件，第二个参数是要挂载的元素

```jsx
import React from "react";
import ReactDOM from "react-dom";

export default class Test extends React.Component {
  render() {
    const portalDOM = ReactDOM.createPortal(<div>portalDOM</div>, document.body);
    return (
      <div>
        <div>test</div>
        {portalDOM}  // 不管写在哪儿都会将其渲染到 body 的最后面
      </div>
    );
  }
}
```



#### 4. 生命周期

##### 4.1. 挂载阶段

`constructor(props)` ：构造函数，虽然不是 react 的生命周期，但会在组件初始化时触发一次。

`static getDerivedStateFromProps(props, state)` ：该函数会在组件实例化后和重新渲染前调用，意味着无论是父组件的更新、props 的变化或通过 setState 更新组件内部的 State，它都会被调用，也就是说在组件装载和更新阶段都会触发；==常用于根据父组件输入的 props 按需更新 state==，这种 state 叫做衍生 state ，返回的对象就是要增量更新的 state，除此之外不应该在里面执行任何其他操作。

`render()` ：初始化和更新都会触发；仅仅用于渲染的纯函数，不能在此函数中修改 props、state 以及数据请求等会触发重新渲染的操作；此渲染函数并不做实际的渲染动作（渲染到 DOM 树），它返回的只是一个 JSX 的描述对象（及组件实例），何时进行真正的渲染是由 React 库决定的。

==`componentDidMount()` ：组件完全挂载到网页上后触发，只在首次渲染之后触发。可用于发送网络请求；任何依赖于 DOM 的初始化操作；添加事件监听；如果使用了 Redux 之类的数据管理工具，也能触发 action 处理数据变化逻辑==

##### 4.2. 更新阶段

`shouldComponentUpdate(nextProps, nextState, nextContext)` ：每次组件因为 state 或 props 变化而更新时，在重新渲染前该生命周期函数都会触发；需要一个返回值，为 true 代表允许更新，若返回 false 则代表取消这次更新渲染；==常用于条件渲染，避免不必要的渲染，从而优化渲染的性能==

`getSnapshotBeforeUpdate(prevProps, prevState)` ：该生命周期函数会在组件即将挂载时触发，它的触发在 render 渲染函数之后。由此可见，render 函数并没有完成挂载操作，而是进行构建抽象 UI（也就是 Virtual DOM）的工作。该生命周期函数执行完毕后就会立即触发 componentDidUpdate 生命周期钩子，并将返回值作为 componentDidUpdate 的第三个参数 。

`componentDidUpdate(prevProps, prevState, snapshot?)` ：组件每次重新渲染后触发，首次渲染时不触发

##### 4.3. 卸载阶段

`componentWillUnmount()` ：在组件卸载和销毁之前触发。用于注销事件监听器；取消网络请求；取消定时器；解绑 DOM 事件。



#### 5. 捕获错误

`static getDerivedStateFromError(error)` ：该生命周期函数会在子孙组件抛出错误时执行，接收抛出的错误作为参数并且需要返回值用于更新 state ，从而显示错误提醒的 UI 

`componentDidCatch` ：和 `getDerivedStateFromError` 一样，只不过没有返回值，而是通过 this.setState 直接修改状态

错误边界：可以定制一个只有 componentDidCatch 生命周期函数的 ErrorBoundary 组件。将需要捕获错误的组件作为 ErrorBoundary 的子组件渲染，一旦子组件抛出错误，整个应用依然不会崩溃，而是被 ErrorBoundary 捕获并显示错误提示

```jsx
import React from 'react';

export default class ErrorBoundary extends React.Component {
  state = { hasError: false };
  render() {
    if (this.state.hasError) {
      return <h1>发生错误.</h1>;
    }
    return this.props.children;
  }

  componentDidCatch(error, info) {
    this.setState({ hasError: true });
  }
}
```



#### 6. 上下文 Context

Context 可以实现跨级传递数据，而不必每层手动通过 props 传递；相当于 vue 的依赖注入

新建 context.js 文件，方便管理与导入

```jsx
import React from "react";
export default React.createContext({ msg: "暂未传参" }); // 参数为 context 的默认值
```

祖先组件：

```jsx
import MyContext from "./context.jsx"; // 导入

// 使用；value 中的数据将传递给子孙组件
<MyContext.Provider value={{ msg: "hello context" }}>
  <Father></Father>
</MyContext.Provider>
```

子孙组件：

```jsx
import MyContext from "./context.jsx";

<MyContext.Consumer>
  // 用一个函数接收祖先组件传递的参数；会往外层找最近的 MyContext.Provider，若没有则使用默认值
  {(context) => {
    console.log(context);
    return <div>{context.msg}</div>;
  }}
</MyContext.Consumer>

// 推荐使用静态属性 contextType 接收参数，更加简便灵活
static contextType = MyContext; // 使用之后就可以直接通过 this.context 获取祖先组件传递的参数
<div>{this.context.msg}</div>
```

hooks 中使用：`const context = useContext(MyContext)`



#### 7. ref

和 vue 的 ref 功能相同，只是实现方式不同

```jsx
export default class Test extends React.Component {
  inputRef = React.createRef();
  // inputRef2;
  getComponent = (component) => {  // 注意写成箭头函数形式，使 this 指向当前组件实例
    this.inputRef2 = component;
  };

  componentDidMount() {
    console.log(this.inputRef.current);  // 需要通过 .current 获取 dom 元素
    console.log(this.inputRef2);  // 可直接获取到 dom 元素（或组件实例）
    this.inputRef.current.focus();
  }
  render() {
    return (
      <div>
        <input type="text" ref={this.inputRef} />
        <input type="text" ref={this.getComponent} />  // 也可以写成函数模式,会传入 dom 元素
      </div>
    );
  }
}
```

应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上则可以获取到组件实例，从而访问子组件数据



---

以下两种代码复用的方式均已被 hooks 取代，了解即可



#### 8. 高阶组件

高阶组件（Higher-Order Component，HOC）是 React 中一种代码重用的模式，==它是一个函数，接受一个组件作为参数，并返回一个新的组件==。它的作用是对组件进行抽象，从而在不修改组件代码的情况下，扩展组件的功能。

封装一个高阶组件，使用的组件延迟3秒展示：

```jsx
export default function delyLoad(WrappedComponent) {
  return class DelyLoadComponent extends React.Component {
    state = {
      isLoad: false,
    };
    componentDidMount() {
      setTimeout(() => {
        this.setState({
          isLoad: true,
        });
      }, 3000);
    }
    render() {
      return this.state.isLoad ? <WrappedComponent /> : <div>加载中</div>;
    }
  };
}

```

使用

```jsx
import delyLoad from "./hoc";
export default delyLoad(
  class Test extends React.Component {
    render() {
      return (
        <div>
           组件内容
        </div>
      );
    }
  }
);
```

高阶组件可以很方便地在组件中统一处理一些通用问题，比如鉴权、数据获取等。例如，我们可以创建一个高阶组件，用来在组件加载前检查用户是否已登录，并在必要时跳转到登录页面等。



#### 9. render props

使父组件可以控制子组件的渲染方式，即具体数据在子组件，而渲染结构在父组件定义

通过传递一个 render 属性，属性值为一个方法，包含要渲染的结构，子组件调用这个方法并传入数据

```jsx
export default class Test extends React.Component {
  render() {
    return (
      <MyComponent
        render={(data) => (
          <ul>
            {data.map((item) => (
              <li key={item.id}>
                {item.name} -- {item.age}
              </li>
            ))}
          </ul>
        )}
      />
    );
  }
}
```

```jsx
export default class MyComponent extends React.Component {
  state = {
    data: [],
  };

  componentDidMount() {
    // 初始化后三秒 塞入数据
    setTimeout(() => {
      this.setState({
        data: [
          { name: "张三", age: 18 },
          { name: "李四", age: 20 },
          { name: "王五", age: 22 },
        ],
      });
    }, 3000);
  }

  render() {
    return this.props.render(this.state.data);
  }
}

```
