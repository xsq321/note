#### 1. 基本使用

安装：`npm i redux react-redux`

创建 store 文件夹，下建 index.js 文件

```jsx
import { legacy_createStore as createStore, combineReducers } from "redux";
import userReducer from "./reducers/user"; 

const rootReducer = combineReducers({ userReducer });  // 合并多个 reducer ，从而实现模块化
const store = createStore(rootReducer);

export default store;
```

在 store 文件夹下新建 reducers 文件夹，下建 user.js 模块

```jsx
const initialState = {
  age: 1,
};

const userReducer = (state = initialState, action) => {
  // action 就是页面中 dispatch 时传递的那个对象
  switch (action.type) {
    case "add": {
      return { ...state, age: state.age + action.payload.val };  // 需使用不可变数据的方式修改
    }
    default:
      return state;
  }
};

export default userReducer;
```

在项目入口文件 index.js 中引入

```jsx
import store from "./store";
import { Provider } from "react-redux";

root.render(
  <Provider store={store}>
    <RouterComponent></RouterComponent>
  </Provider>
);
```

页面中使用

```jsx
import { useSelector, useDispatch } from "react-redux";

export default function Test() {
  const num = useSelector((state) => state.user.age); // 获取时需先找到对应的模块
  const dispatch = useDispatch();
  return (
    <div>
      <div>{age}</div>
      // dispatch 是直接使用，不需要区分模块，所以需要注意 type 的取值；payload 为其他参数
      <button onClick={() => dispatch({ type: "add", payload: {val:2} })}>age+2</button>
    </div>
  );
}

```



#### 2. 常用方法

| 常用方法                    | 作用                                                      |
| --------------------------- | --------------------------------------------------------- |
| `store.getState()`          | 返回仓库当前的 state                                      |
| `store.dispatch()`          | 触发 state 变化，不过一般都使用 useDispatch()             |
| `store.subscribe(() => {})` | 监听 state 的变化，每当 dispatch 时就会执行里面的回调函数 |
|                             |                                                           |



#### 3. 命名空间模块

为了防止 type 名冲突，也为了统一管理

在 store 文件夹下新建 namespace 文件夹，下建 user.js 文件（和模块同名）

```jsx
const module = "user";

const generateType = (name) => {
  return `${module}/${name}`;
};

export const ADD = generateType("add"); // 一般大写
```

统一管理一个模块的操作类型名，使用的地方按需引入即可，修改也只需修改这一处



#### 4. redux 中间件

使用 applyMiddleware 可以为 redux 添加中间件，从而在 dispatch 操作前后进行一些操作

使用 immer 封装一个 redux 的中间件，让所有的修改数据都是以不可变数据的方式进行修改：

在 store 文件夹下新建 middlewares 文件夹，下建 immerMiddleware.js 文件

```jsx
import { produce } from 'immer';

// 看不太懂，反正就是拿到 reducer 返回的结果，并对其进行重新赋值
const immerMiddleware = store => next => action => {
  const newState = produce(store.getState(), draft => {
    draft = next(action);
  });
  return newState;
};

export default immerMiddleware;
```

使用中间件，多个中间件用逗号隔开

```jsx
const store = createStore(rootReducer, applyMiddleware(immerMiddleware))
```



#### 5. bindActionCreators 

用于封装 action 

在 store 文件夹下新建 actions 文件夹，下建 user.js 文件

```jsx
import { ADD } from "../namespace/user";

function addAge(val) {
  // 可在这里写一些操作
  return {  // 这就是 dispatch 时传的参数，也就是 reducer 中的 action
    type: ADD,
    payload: { val },
  };
}

const userActionCreators = { addAge }
export default userActionCreators;
```

在 store 文件夹下新建 utils.js

```jsx
import { useDispatch } from "react-redux";
import { bindActionCreators } from "redux";
import { useMemo } from "react";

export function useActions(actionCreators) {
  const dispatch = useDispatch();
  return useMemo(() => {  // 防止不必要的重新绑定
    return bindActionCreators(actionCreators, dispatch);  // 将 action 与 diapatch 绑定
  }, [actionCreators]);
}
```

页面中使用

```jsx
import { useActions } from "./store/utils";
import userActionCreators from "./store/actions/user";

const actions = useActions(userActionCreators);
actions.addAge(2);  // 这样就可以直接触发状态更新了，而不需要调用 dispatch 
```



#### 6. redux-thunk

是一个用于处理 redux 异步 action 的中间件

```jsx
npm i redux-thunk  // 下载
import thunk from 'redux-thunk'
const store = createStore(rootReducer, applyMiddleware(thunk)) // 使用中间件
```

这样就可以使 action 支持异步操作

```jsx
// store/actions/user.js

const dely = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(10);
    }, 1000);
  });
};

function addAge(val) {
  return async (dispatch, getState) => {  // 需要返回一个函数，在这个函数里面可以进行异步操作
    await dely();
    dispatch({  // 这时就需要自己调用 dispatch 
      type: ADD,
    	payload: { val },
    })
  }
}
```



