#### 1. 基本使用

安装：`npm i redux react-redux @reduxjs/toolkit`

创建 store 文件夹，下建 index.js

```jsx
import { configureStore } from "@reduxjs/toolkit";
import userReducer from "./slices/user";

const store = configureStore({
  reducer: {
    user: userReducer, // 模块化
  },
});

export default store;
```

在 store 文件夹下新建 slices 文件夹，下建 user.js 模块

```jsx
import { createSlice } from "@reduxjs/toolkit";

const userSlice = createSlice({
  name: "user",
  initialState: { age: 16 },
  reducers: {
    addAge: (state, action) => {
      return { ...state, age: state.age + action.payload.val };
    },
  },
});

const userReducer = userSlice.reducer;
export default userReducer;
export const { addAge } = userSlice.actions;  // 会自动生成和 reducer 同名的 action
```

在项目入口文件 index.js 中引入

```jsx
import store from "./store";
import { Provider } from "react-redux";

root.render(
  <Provider store={store}>
    <RouterComponent></RouterComponent>
  </Provider>
);
```

页面中使用

```jsx
import { useSelector, useDispatch } from "react-redux";
import { addAge } from "./store/slices/user";

export default function Test3() {
  const { age } = useSelector((state) => state.user);
  const dispatch = useDispatch();
  return (
    <div>
      <div>{age}</div>
      // addAge 中的参数需写成一个对象，即 payload 对象
      <button onClick={() => dispatch(addAge({ val: 3 }))}>age+3</button>
    </div>
  );
}
```



#### 2. extraReducers

是 createSlice 里面的一个属性，可以用于添加额外的 reducer ，这些额外的 reducer 可以处理来自其他 Slice 的 action 或其他非标准的 action 类型，如异步 action 

```jsx
const userSlice = createSlice({
  ...
  extraReducers: (builder) => {
    builder.addCase("user/updateName", (state, action) => {
      state.name = action.payload.name;  // 可直接修改state，toolkit内部使用了immer库
    }).addCase(...);  // 可在后面继续跟 .addCase 添加 reducer
  },
});
```

新建 actions 文件夹，下建 user.js 文件

```jsx
export const updateName = (name) => {
  return {
    type: "user/updateName",
    payload: { name },
  };
};
```

页面中使用

```jsx
<input type="text" onChange={(e) => dispatch(updateName(e.target.value))} />
```



#### 3. createAsyncThunk

createAsyncThunk 是一个由 Redux Toolkit 提供的函数，用于创建处理异步操作的 thunk action creator。

actions/user.js 中

```jsx
const delay = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, 1000);
  });
};
export const asyncAddAge = createAsyncThunk(
  "user/asyncAddAge",
  // arg 为页面调用 asyncAddage 是传递的参数，如果状态的修改需要用到则建议直接在这里 dispatch ，页面使用时直接调用该函数即可
  async (arg, { dispatch, getState, extra }) => {
    await delay();
    const { user } = getState();
    if (user.age === 20) {  // 实际会通过异步函数的返回结果进行判断
      throw new Error("age为20时报错");
    }
  }
);
```

reducers/user.js 中

```jsx
// 会根据 asyncAddAge 返回的不同状态触发不同的 reducer ，分别对应等待，成功，错误
	extraReducers: (builder) => {
    builder
      .addCase(asyncAddAge.pending, (state) => {
        state.status = "loading";
      })
      .addCase(asyncAddAge.fulfilled, (state, action) => {
        console.log(action);
        state.age += 1;
        state.status = "success";
        state.error = "";
      })
      .addCase(asyncAddAge.rejected, (state, action) => {
        console.log(action);
        state.status = "error";
        state.age += 1  // 不加这句则会永远处于 error 状态
        state.error = action.error.message;
      });
  },
```

页面中使用

```jsx
<button onClick={() => dispatch(asyncAddAge())}>age异步+1</button>
```



#### 4. createSelector

createSelector 函数主要用于优化 React 的性能，特别是在具有大量数据的情况下。它的主要用途是创建输出选择器函数，该函数将redux store中的多个状态组合并到单个值中，并将该值缓存以提高性能

其实就是用来缓存一些复杂的操作，相当于计算属性

创建 selectors 文件夹，下建 user.js 文件

```jsx
import { createSelector } from '@reduxjs/toolkit'

export const nameAndAge = createSelector(
  // 导出的 user 会传给后面的函数，直到最后那个返回就是 nameAndAge 的值
  (state) => state.user,
  (user) => {
    // 只有当前模块的数据发生变化时才重新调用（计算）
    console.log("触发")
    return {
      name: user.name,
      age: user.age
    }
  }
)
```

页面中使用

```jsx
import { nameAndAge } from "./store/selectors/user";
const {name, age} = useSelector(nameAndAge);
```



















