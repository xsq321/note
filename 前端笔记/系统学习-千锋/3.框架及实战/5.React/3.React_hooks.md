函数 return 返回的是 jsx 代码，那么它就是一个函数式组件；如果不返回 jsx 而是返回一些方法或属性，那就是一个自定义的 hooks ，钩子一律使用 useXxx 命名



| 常用 hooks             | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `useState(1)`          | 用于状态管理，`const [num, setNum] = useState(1)`            |
| `useEffect(()=>{},[])` | 第一个参数是回调函数，第二个参数是依赖项；可用于执行副作用操作 |
| `useContext()`         | 接收祖先组件传递的 context                                   |
| `useMemo(()=>{},[])`   | 只有当依赖项发生变化时才重新运行回调函数进行值的计算         |
|                        |                                                              |
|                        |                                                              |
|                        |                                                              |



#### 1. useState

用于在函数组件中进行状态管理，接收一个初始状态，并返回一个数组，其中包含当前状态和一个函数，用于更新当前状态

```jsx
const [num, setNum] = useState(1)
// 也可写成函数形式：useState(() => {return initialValue}) ，常用于初始值的计算比较复杂的情况
setNum(num + 1)  // 传入一个新值即可修改 num 
// 也可写成函数形式：setNum((pre) => {return pre+1})，接收一个参数，为修改前的值
```

==setNum() 会导致组件重新渲染，而 hooks 里的重新渲染就是函数组件的重新调用==，也就是说没有用 useState 管理的变量会回归初始值，而 useState 运用了链表+闭包的形式保存住了值；setNum 是异步修改状态，也就是说不能在后面直接获得最新值，只能通过 useEffect 监听获得最新值



#### 2. useEffect

useEffect 可以让你在函数组件中执行副作用操作，接收两个参数，第一个参数是要执行的回调函数；第二个参数是可选的依赖项数组，如果没有则回调函数在==每次函数组件渲染后都会执行==（包括初始化），如果有则只有在依赖项发生变化时才==异步的==执行回调函数（利用这个可以实现监听，可写多个 useEffect 监听不同状态的变化）

所有会导致组件重新渲染的操作都可能存在副作用，而这些副作用可以写在 useEffect 中进行统一管理；相当于类组件中的生命周期的合集

```jsx
import { useState, useEffect } from "react";

export default function Test() {
  const [num, setNum] = useState(1);
  const [num2, setNum2] = useState(1);
  useEffect(() => {
    console.log("执行一些副作用操作...");
    console.log("num2变化了");
    // useEffect 在每次重新渲染时都会先卸载已有的监听再重新监听，并且会运行 return 返回的函数
    return () => {
      console.log("卸载");
    };
  }, [num2]);
  return (
    <div>
      <div>num: {num}，num2: {num2}</div>
      <button onClick={() => setNum(num + 1)}>num+1</button>
      <button onClick={() => setNum2(num2 + 1)}>num2+1</button>
    </div>
  );
}
```



#### 3. useContext

在 hooks 中使用 context 上下文的方式，传递方式不变，只有接收方式变了

```jsx
const context = useContext(MyContext)  // context 就是祖先组件传递过来的数据
```



#### 4. useMemo

接收两个参数，一个回调函数和一个依赖项列表；只有当依赖项改变时才运行函数重新计算，否则使用缓存的值，从而在组件重新渲染时避免不必要的重新计算

```jsx
const doubleNum = useMemo(() => {
  console.log("重新计算");
  return num * 2;  // 返回值就是 doubleNum 的值
}, [num]);
```

如果在组件中执行了复杂的计算，并且这些计算结果不需要频繁更新，那么就可以使用 useMemo 优化组件性能



#### 5. useCallback

接收两个参数，一个回调函数和一个依赖项列表。当依赖项列表中的任意一项改变时，useCallback 会重新定义回调函数，否则它会返回一个缓存的函数引用，从而避免不必要的函数重新创建。

```jsx
const addNum = useCallback((val) => {  // 回调函数本身就是 addNum 的值
  console.log(num);
  setNum(num + val);
}, [num]);  // 只有 num 改变引起的重新渲染才会使函数重新定义
```

注意，第二个参数不传代表每次都改变；传一个空数组则代表每次都不变，这时函数引用就会永远被缓存，函数引用被缓存后，函数里面就拿不到外面最新的值了，会形成过期闭包，num 永远是初始值，函数也就失效了，所以要格外注意依赖项的值，即需要实现让函数被调用一次后就重新定义。

在已经使用 React.memo() 的情况下，父组件给子组件传递了一个函数，父组件重新渲染时函数会被重新定义导致 props 变化，使得子组件也重新渲染，这时可用 useCallback 避免子组件的重新渲染。



















### 其他相关内容

#### 1. 不可变数据

Immutable Data 是指一种一旦创建就不能更改的数据结构，即原始数据不应该被修改，想修改只能通过深拷贝给一个新对象。

在 react 中修改数据如果直接通过原对象进行修改的话，数据虽然变了，但引用地址相同，虚拟 dom 会认为前后没有发生变化，页面就不会更新了；如果不考虑原数据不可变的话，最简单的方式就是直接改变原数据，然后通过扩展运算符更新 `setArr([...arr])` 。

但如果想保证原数据不可变的话，则可以使用深拷贝的方式；如果数据比较深、比较大的话会比较耗性能，这时可选择使用 immer 库，使用也方便：

```jsx
import produce from 'immer'
const newVal = porduce(arr, draft => {
  // draft 就相当于 arr ，直接对 draft 进行修改即可产生一个新对象 newVal
  draft.push('新数据')
})
setArr(newVal)
```



#### 2. hooks 父子组件传值

和类组件传值一样，唯一不同就是需要将 props 作为参数传入函数组件

```jsx
export default function Son(props){}
```



#### 3. React.memo & React.PureComponent

React.memo 是一个高阶组件，可提高渲染性能；props 不变的情况下不会重新渲染，而是直接复用最近一次渲染的结果；当然，不会影响子组件自身的重新渲染逻辑，这里说的是父组件重新渲染时子组件不会跟着重新渲染

```jsx
const MyComponent =  React.memo((props) => {
  return (
    <div>{props.num}</div>
  )
}, (prevProps, nextProps) => {})
```

默认情况下其只会对复杂对象做浅层对比；若想控制对比过程，可传递第二个参数，也是一个函数，返回 true 不渲染，false 渲染

和类组件中 PureComponent 类似：React.PureComponent 是一个特殊的 React 组件类，它可以自动实现浅层比较（shallow comparison），决定是否需要重新渲染组件

```jsx
class MyComponent extends React.PureComponent {render(){...}}
```

因此，如果你的组件是一个展示型组件，且不需要经常更新，那么可以考虑使用 React.PureComponent 来优化组件的性能













