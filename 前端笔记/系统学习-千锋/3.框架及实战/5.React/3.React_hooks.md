函数 return 返回的是 jsx 代码，那么它就是一个函数式组件；如果不返回 jsx 而是返回一些方法或属性，那就是一个自定义的 hooks ，钩子一律使用 useXxx 命名



| 常用 hooks               | 作用                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `useState(1)`            | 用于状态管理，`const [num, setNum] = useState(1)`            |
| `useEffect(()=>{},[])`   | 第一个参数是回调函数，第二个参数是依赖项；可用于执行副作用操作 |
| `useContext()`           | 接收祖先组件传递的 context                                   |
| `useMemo(()=>{},[])`     | 缓存计算结果                                                 |
| `useCallback(()=>{},[])` | 缓存函数引用                                                 |
| `useReducer(()=>{},1)`   | `const [state, dispatch] = useReducer((state, action)=>{}, 1);` ，可用于全局状态管理 |
| `useRef(1)`              | 和 useState 类似，都可以保存值，防止重置，但改变它并不会触发重新渲染 |
|                          |                                                              |
|                          |                                                              |



#### 1. useState

用于在函数组件中进行状态管理，接收一个初始状态，并返回一个数组，其中包含当前状态和一个函数，用于更新当前状态

```jsx
const [num, setNum] = useState(1)
// 也可写成函数形式：useState(() => {return initialValue}) ，常用于初始值的计算比较复杂的情况
setNum(num + 1)  // 传入一个新值即可修改 num 
// 也可写成函数形式：setNum((pre) => {return pre+1})，接收一个参数，获取当前值；可处理复杂逻辑，且可用于解决过期闭包的问题
```

==setNum() 会导致组件重新渲染，而 hooks 里的重新渲染就是函数组件的重新调用==，也就是说没有用 useState 管理的变量会回归初始值，而 useState 运用了链表+闭包的形式保存住了值；setNum 是异步修改状态，也就是说不能在后面直接获得最新值，只能通过 useEffect 监听获得最新值



#### 2. useEffect

useEffect 可以让你在函数组件中执行副作用操作，接收两个参数，第一个参数是要执行的回调函数；第二个参数是可选的依赖项数组，如果没有则回调函数在==每次函数组件渲染后都会执行==（包括初始化）；如果有则只有在依赖项发生变化时才==异步的==执行回调函数（利用这个可以实现监听，可写多个 useEffect 监听不同状态的变化）；而如果是一个空数组，则只在初始化时执行一次，并只在组件卸载时执行 return 的那个函数

所有会导致组件重新渲染的操作都可能存在副作用，而这些副作用可以写在 useEffect 中进行统一管理；相当于类组件中的生命周期的合集

```jsx
import { useState, useEffect } from "react";

export default function Test() {
  const [num, setNum] = useState(1);
  const [num2, setNum2] = useState(1);
  useEffect(() => {
    console.log("执行一些副作用操作...");
    console.log("num2变化了");
    // useEffect 在每次重新调用时都会先卸载已有的监听再重新监听，并且会运行 return 返回的函数
    return () => {
      console.log("卸载");
    };
  }, [num2]);
  return (
    <div>
      <div>num: {num}，num2: {num2}</div>
      <button onClick={() => setNum(num + 1)}>num+1</button>
      <button onClick={() => setNum2(num2 + 1)}>num2+1</button>
    </div>
  );
}
```



#### 3. useContext

在 hooks 中使用 context 上下文的方式，传递方式不变，只有接收方式变了

```jsx
const context = useContext(MyContext)  // context 就是祖先组件传递过来的数据
```



#### 4. useMemo

接收两个参数，一个回调函数和一个依赖项列表；只有当依赖项改变时才运行函数重新计算，否则使用缓存的值，从而在组件重新渲染时避免不必要的重新计算

```jsx
const doubleNum = useMemo(() => {
  console.log("重新计算");
  return num * 2;  // 返回值就是 doubleNum 的值
}, [num]);
```

如果在组件中执行了复杂的计算，并且这些计算结果不需要频繁更新，那么就可以使用 useMemo 优化组件性能



#### 5. useCallback

接收两个参数，一个回调函数和一个依赖项列表。当依赖项列表中的任意一项改变时，useCallback 会重新定义回调函数，否则它会返回一个缓存的函数引用，从而避免不必要的函数重新创建。

```jsx
const addNum = useCallback((val) => {  // 回调函数本身就是 addNum 的值
  console.log(num);
  setNum(num + val);
}, [num]);  // 只有 num 改变引起的重新渲染才会使函数重新定义
```

注意，第二个参数不传代表每次重新渲染都改变；传一个空数组则代表每次都不变，这时函数引用就会永远被缓存，函数引用被缓存后，函数里面就拿不到外面最新的值了，会形成==过期闭包==，num 永远是初始值，函数也就失效了，所以要格外注意依赖项的值，即需要实现让函数被调用一次后就重新定义一次。

在已经使用 React.memo() 的情况下，父组件给子组件传递了一个函数，父组件重新渲染时函数会被重新定义导致 props 变化，使得子组件也重新渲染，这时可用 useCallback 避免子组件的重新渲染。



#### 6. useReducer

可用于全局状态管理，且适用于状态更新逻辑比较复杂的情况

```jsx
import { useReducer } from "react";
export default function Test() {
  const [state, dispatch] = useReducer(
    (state, action) => {
      switch (action.type) {  // 规定传参时必须是个含有 type 属性的对象
        case "add":
          state.num += 1;
          break;
        case "dec":
          state.num -= 1;
          break;
      }
      return { ...state };  // 返回值就是修改后的 state 
    },
    { num: 1 }  // state 初始值
  );
  return (
    <div>
      <div>{state.num}</div>
      // 外部只需调用 dispatch 并传入想实现的操作类型即可，不需要知道具体的
      <button onClick={() => dispatch({ type: "add" })}>+1</button>
      <button onClick={() => dispatch({ type: "dec" })}>-1</button>
    </div>
  );
}
```

配合 useContext 即可实现状态共享；如果直接进行模块化的话每次引入时都会重新调用 useReducer 创建一个新的仓库，所以并不能直接通过这种方式实现状态共享，vuex 与 pinia 能实现应该是做了一次判断，就是如果仓库已经存在了就沿用之前创建的，这也是为什么需要将 pinia 挂载到 app 上的原因，可能就是为了将创建好的仓库保存到 app 上（猜测）



#### 7. useRef

和 useState 类似，都可以保存值，防止值被重置，但改变它不会触发重新渲染；实现的效果类似于直接在函数组件外创建的一个变量

```jsx
const ref = useRef(1)  // useRef 返回一个只有一个 current 属性的对象，参数即为初始值
```

和 React.createRef() 一样，可用于获取并操作 DOM 

```jsx
export default function Test() {
  const inputRef = useRef(null);
  useEffect(() => {
    inputRef.current.focus();
  }, []);
  return (
    <div>
      <input type="text" ref={inputRef} />
    </div>
  );
}
```

函数组件没有组件实例，也就是说获取不到子组件的 ref ，只能通过 forwardRef 获取子组件的某个 dom 元素



#### 8. useImperativeHandle

useImperativeHandle 可以让父组件获取并执行子组件内某些自定义函数(方法)。本质上其实是子组件将自己内部的函数(方法)通过 useImperativeHandle 添加到父组件 useRef 定义的对象中。

```jsx
useImperativeHandle(ref, () => {
  return { add }
}, [num])
```

第一个参数是ref，父组件传过来的，就是要将方法添加到这个对象上；第二个参数是一个方法，必须有返回值，返回的值就是 ref.current 的值；第三个参数是依赖项。具体查看详细笔记



#### 9. useDeferredValue & useTransition

这两个钩子可以让组件延迟渲染不紧急的部分，类似于防抖但不需要使用固定的延迟时间，延迟的渲染会在紧急的部分先出现在浏览器屏幕以后才开始，并且可中断不会阻塞用户输入。

简单理解就是如果说某些渲染比较消耗性能，比如存在实时计算和反馈，就可以使用这个 Hook 降低其计算的优先级，避免整个应用变得卡顿。较多的场景可能就在于用户反馈输入上，比如百度的输入框，用户在输入的时候，页面会发生变化，但是输入框输入并不卡顿。

##### 9.1. useDeferredValue

接收一个要变化的参数，该参数会被打上标记低优先级更新， 返回一个延迟响应的状态。

```jsx
const deferredValue = useDeferredValue(value)
```

页面中对 deferredValue 的渲染就会被延迟，并且如果 value 变化很快 deferredValue 的渲染还会被打断，但渲染次数并不会减少，这是和防抖最主要的区别

##### 9.2. useTransition

```jsx
const [isPending, startTransition] = useTransition();
```

isPending 是个布尔值，它指示低优先级状态更新是否仍处于挂起状态，true 代表挂起，即还未被重新渲染，false 代表渲染完成；startTransition 是个函数，接收一个参数，参数也是一个函数，这里面的任务都将是低优先级的

##### 9.3. 区别

useDeferredValue 是延迟渲染一个状态，而 useTransition 则是延迟处理一段逻辑



#### 10. useId

用于生成随机且唯一的 id ，如果直接使用 Math.random() 会造成客户端与服务端生成的 id 不匹配的问题

```jsx
const id = useId()
```







### 其他相关内容



#### 1. 不可变数据

Immutable Data 是指一种一旦创建就不能更改的数据结构，即原始数据不应该被修改，想修改只能通过深拷贝给一个新对象。

在 react 中修改数据如果直接通过原对象进行修改的话，数据虽然变了，但引用地址相同，虚拟 dom 会认为前后没有发生变化，页面就不会更新了；如果不考虑原数据不可变的话，==最简单的方式就是直接改变原数据，然后通过扩展运算符更新 `setArr([...arr])`==。

但如果想保证原数据不可变的话，则可以使用深拷贝的方式；但如果数据比较深、比较大的话会比较耗性能，这时可选择使用 immer 库，使用也方便：

```jsx
import produce from 'immer'
const newVal = porduce(arr, draft => {
  // draft 就相当于 arr ，直接对 draft 进行修改即可产生一个新对象 newVal ，不需要返回
  draft.push('新数据')
})
setArr(newVal)
```



#### 2. hooks 父子组件传值

和类组件传值一样，唯一不同就是需要将 props 作为参数传入函数组件

```jsx
export default function Son(props){}
```



#### 3. React.memo & React.PureComponent

React.memo 是一个高阶组件，可提高渲染性能；props 不变的情况下不会重新渲染，而是直接复用最近一次渲染的结果；当然，不会影响子组件自身的重新渲染逻辑，这里说的是父组件重新渲染时子组件不会跟着重新渲染

```jsx
const MyComponent =  React.memo((props) => {
  return (
    <div>{props.num}</div>
  )
}, (prevProps, nextProps) => {})
```

默认情况下其只会对复杂对象做浅层对比；若想控制对比过程，可传递第二个参数，也是一个函数，返回 true 不渲染，false 渲染

和类组件中 PureComponent 类似：React.PureComponent 是一个特殊的 React 组件类，它可以自动实现浅层比较（shallow comparison），决定是否需要重新渲染组件

```jsx
class MyComponent extends React.PureComponent {render(){...}}
```

因此，如果你的组件是一个展示型组件，且不需要经常更新，那么可以考虑使用 React.PureComponent 来优化组件的性能



#### 4. hooks 模拟生命周期

```jsx
componentDidMount: useEffect(()=>{}, []) // 依赖项不传代表每次重现渲染都执行；传一个空数组代表每次重新渲染都不执行，只执行初始化渲染这一次
shouldComponentUpdate: React.memo((props)=>{}, (preProps, nextProps)=>{}) // 返回 true 不渲染，返回 false 渲染；不过只能模拟一部分功能，即只能根据 props 决定是否渲染 
componentWillUnmount: useEffect(()=>{return ()=>{}}, []) // return 的那个函数就会在组件卸载之前运行，注意依赖项为空数组
componentDidUpdate: useEffect(() => {  // 注意 isInit 的声明需放在组件外面或使用 useRef()
                      if (isInit === true) { isInit = false; return; }
                      console.log("componentDidUpdate");
                    });  // 不传第二个参数
```



#### 5. 过期闭包

过期闭包（stale closure）是指一个闭包在创建之后，所引用的外部作用域内的变量已经被修改，但闭包内仍然保存了旧值。

在 React 中，过期闭包问题是指因为闭包的生命周期长于其引用的变量的生命周期而导致的问题。
在 React 组件的 render 函数中，如果使用了闭包引用组件的 state 或 props ，当 state 或 props 发生变化时，闭包将不会自动更新引用的变量。这就可能导致闭包引用了错误的值，从而导致组件的不正确行为。

除了 useCallback 中的过期闭包外，在 useEffect 中的异步函数以及 setState() 的异步调用都有可能产生过期闭包问题，其中 setState() 可采用 setState((a) => a + 1) 这种方式修改值，具体查看详细笔记-5-31



#### 6. React.forwardRef

可使子组件能够接收父组件传递下来的 ref 属性

```jsx
const Son = React.forwardRef((props, ref) => {
  // 子组件内容，其实就是用 forwardRef 包裹子组件
});
export default Son
```



