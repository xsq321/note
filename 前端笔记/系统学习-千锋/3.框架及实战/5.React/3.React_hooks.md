函数 return 返回的是 jsx 代码，那么它就是一个函数式组件；如果不返回 jsx 而是返回一些方法或属性，那就是一个自定义的 hooks ，钩子一律使用 useXxx 命名



| 常用 hooks                | 作用                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `useState(1)`             | 用于状态管理，`const [num, setNum] = useState(1)`            |
| `useEffect(()=>{},[])`    | 第一个参数是回调函数，第二个参数是依赖项；可用于执行副作用操作 |
| `useContext()`            | 接收祖先组件传递的 context                                   |
| `React.memo((props)=>{})` | props 不变的情况下子组件不会跟着父组件重新渲染，从而提高组件性能 |
| `useMemo(()=>{},[])`      | 缓存计算结果                                                 |
| `useCallback(()=>{},[])`  | 缓存函数引用                                                 |
|                           |                                                              |
|                           |                                                              |



#### 1. useState

用于在函数组件中进行状态管理，接收一个初始状态，并返回一个数组，其中包含当前状态和一个函数，用于更新当前状态

```jsx
const [num, setNum] = useState(1)
// 也可写成函数形式：useState(() => {return initialValue}) ，常用于初始值的计算比较复杂的情况
setNum(num + 1)  // 传入一个新值即可修改 num 
// 也可写成函数形式：setNum((pre) => {return pre+1})，接收一个参数，获取当前值；可处理复杂逻辑，切可用于解决过期闭包的问题
```

==setNum() 会导致组件重新渲染，而 hooks 里的重新渲染就是函数组件的重新调用==，也就是说没有用 useState 管理的变量会回归初始值，而 useState 运用了链表+闭包的形式保存住了值；setNum 是异步修改状态，也就是说不能在后面直接获得最新值，只能通过 useEffect 监听获得最新值



#### 2. useEffect

useEffect 可以让你在函数组件中执行副作用操作，接收两个参数，第一个参数是要执行的回调函数；第二个参数是可选的依赖项数组，如果没有则回调函数在==每次函数组件渲染后都会执行==（包括初始化）；如果有则只有在依赖项发生变化时才==异步的==执行回调函数（利用这个可以实现监听，可写多个 useEffect 监听不同状态的变化）；而如果是一个空数组，则只在初始化时执行一次，并只在组件卸载时执行 return 的那个函数

所有会导致组件重新渲染的操作都可能存在副作用，而这些副作用可以写在 useEffect 中进行统一管理；相当于类组件中的生命周期的合集

```jsx
import { useState, useEffect } from "react";

export default function Test() {
  const [num, setNum] = useState(1);
  const [num2, setNum2] = useState(1);
  useEffect(() => {
    console.log("执行一些副作用操作...");
    console.log("num2变化了");
    // useEffect 在每次重新渲染时都会先卸载已有的监听再重新监听，并且会运行 return 返回的函数
    return () => {
      console.log("卸载");
    };
  }, [num2]);
  return (
    <div>
      <div>num: {num}，num2: {num2}</div>
      <button onClick={() => setNum(num + 1)}>num+1</button>
      <button onClick={() => setNum2(num2 + 1)}>num2+1</button>
    </div>
  );
}
```



#### 3. useContext

在 hooks 中使用 context 上下文的方式，传递方式不变，只有接收方式变了

```jsx
const context = useContext(MyContext)  // context 就是祖先组件传递过来的数据
```



#### 4. React.memo & React.PureComponent

React.memo 是一个高阶组件，可提高渲染性能；props 不变的情况下不会重新渲染，而是直接复用最近一次渲染的结果；当然，不会影响子组件自身的重新渲染逻辑，这里说的是父组件重新渲染时子组件不会跟着重新渲染

```jsx
const MyComponent =  React.memo((props) => {
  return (
    <div>{props.num}</div>
  )
}, (prevProps, nextProps) => {})
```

默认情况下其只会对复杂对象做浅层对比；若想控制对比过程，可传递第二个参数，也是一个函数，返回 true 不渲染，false 渲染

和类组件中 PureComponent 类似：React.PureComponent 是一个特殊的 React 组件类，它可以自动实现浅层比较（shallow comparison），决定是否需要重新渲染组件

```jsx
class MyComponent extends React.PureComponent {render(){...}}
```

因此，如果你的组件是一个展示型组件，且不需要经常更新，那么可以考虑使用 React.PureComponent 来优化组件的性能



#### 5. useMemo

接收两个参数，一个回调函数和一个依赖项列表；只有当依赖项改变时才运行函数重新计算，否则使用缓存的值，从而在组件重新渲染时避免不必要的重新计算

```jsx
const doubleNum = useMemo(() => {
  console.log("重新计算");
  return num * 2;  // 返回值就是 doubleNum 的值
}, [num]);
```

如果在组件中执行了复杂的计算，并且这些计算结果不需要频繁更新，那么就可以使用 useMemo 优化组件性能



#### 6. useCallback

接收两个参数，一个回调函数和一个依赖项列表。当依赖项列表中的任意一项改变时，useCallback 会重新定义回调函数，否则它会返回一个缓存的函数引用，从而避免不必要的函数重新创建。

```jsx
const addNum = useCallback((val) => {  // 回调函数本身就是 addNum 的值
  console.log(num);
  setNum(num + val);
}, [num]);  // 只有 num 改变引起的重新渲染才会使函数重新定义
```

注意，第二个参数不传代表每次重新渲染都改变；传一个空数组则代表每次都不变，这时函数引用就会永远被缓存，函数引用被缓存后，函数里面就拿不到外面最新的值了，会形成==过期闭包==，num 永远是初始值，函数也就失效了，所以要格外注意依赖项的值，即需要实现让函数被调用一次后就重新定义一次。

在已经使用 React.memo() 的情况下，父组件给子组件传递了一个函数，父组件重新渲染时函数会被重新定义导致 props 变化，使得子组件也重新渲染，这时可用 useCallback 避免子组件的重新渲染。



#### 7. useReducer

可用于全局状态管理，用法类似 useState ，

```jsx
const [state, dispatch] = useReducer((state, action)=>{}, 1);
```























### 其他相关内容



#### 1. 不可变数据

Immutable Data 是指一种一旦创建就不能更改的数据结构，即原始数据不应该被修改，想修改只能通过深拷贝给一个新对象。

在 react 中修改数据如果直接通过原对象进行修改的话，数据虽然变了，但引用地址相同，虚拟 dom 会认为前后没有发生变化，页面就不会更新了；如果不考虑原数据不可变的话，==最简单的方式就是直接改变原数据，然后通过扩展运算符更新 `setArr([...arr])`==。

但如果想保证原数据不可变的话，则可以使用深拷贝的方式；如果数据比较深、比较大的话会比较耗性能，这时可选择使用 immer 库，使用也方便：

```jsx
import produce from 'immer'
const newVal = porduce(arr, draft => {
  // draft 就相当于 arr ，直接对 draft 进行修改即可产生一个新对象 newVal
  draft.push('新数据')
})
setArr(newVal)
```



#### 2. hooks 父子组件传值

和类组件传值一样，唯一不同就是需要将 props 作为参数传入函数组件

```jsx
export default function Son(props){}
```



#### 3. hooks 模拟生命周期

```jsx
componentDidMount: useEffect(()=>{}, []) // 依赖项不传代表每次重现渲染都执行；传一个空数组代表每次重新渲染都不执行，只执行初始化渲染这一次
shouldComponentUpdate: React.memo((props)=>{}, (preProps, nextProps)=>{}) // 返回 true 不渲染，返回 false 渲染；不过只能模拟一部分功能，即只能根据 props 决定是否渲染 
componentWillUnmount: useEffect(()=>{return ()=>{}}, []) // return 的那个函数就会在组件卸载之前运行，注意依赖项为空数组
componentDidUpdate: useEffect(() => {  // 注意 isInit 的声明需放在组件外面或使用 useRef()
                      if (isInit === true) { isInit = false; return; }
                      console.log("componentDidUpdate");
                    });  // 不传第二个参数
```



#### 4. 过期闭包

过期闭包（stale closure）是指一个闭包在创建之后，所引用的外部作用域内的变量已经被修改，但闭包内仍然保存了旧值。

在 React 中，过期闭包问题是指因为闭包的生命周期长于其引用的变量的生命周期而导致的问题。
在 React 组件的 render 函数中，如果使用了闭包引用组件的 state 或 props ，当 state 或 props 发生变化时，闭包将不会自动更新引用的变量。这就可能导致闭包引用了错误的值，从而导致组件的不正确行为。

除了 useCallback 中的过期闭包外，在 useEffect 中的异步函数以及 setState() 的异步调用都有可能产生过期闭包问题，其中 setState() 可采用 setState((a) => a + 1) 这种方式修改值，具体查看详细笔记-5-31





















