#### 1. 项目创建

```bash
npm i create-react-app -g  // 全局安装 react 脚手架
create-react-app xxx  // 创建项目
```

非必要不要使用 `npm run eject` 暴漏配置文件；那如何在不暴露 eject 的情况下，对 webpack 进行二次封装呢，如配置路径别名（@）、配置代理服务器等



#### 2. 组件定义

##### 2.1. 类组件

```jsx
import React from "react";
export default class ClassComponent extends React.Component {
  render() {
    return (
      <div>
        <p>hello react</p>
      </div>
    );
  }
}
```

##### 2.2. 函数组件

```jsx
export default function FunctionComponent() {
  return (
    <div>
      <p>function component</p>
    </div>
  );
}
```

##### 2.3. 区别

1、类组件有生命周期，函数组件没有
2、类组件需要继承 Class，函数组件不需要
3、类组件可以获取实例化的 this，并且基于 this 做各种操作，函数组件不行
4、类组件内部可以定义并维护 state， 函数组件都称为无状态了，那肯定不行。

==函数式组件捕获了渲染时所使用的值，这是两类组件最大的不同==



#### 3. jsx 语法入门

```jsx
const jsx = <div></div>;  // 换行时需用小括号括起来；注意只能有一个根元素

const hello = "你好";
const jsx3 = <div>{hello}</div>;  // 可在大括号里面使用变量；大括号中也可使用表达式，如三元运算等
```

其实 JSX 元素就是调用 React.createElement(component, props, ...children) 的语法糖

```jsx
// React.createElement(组件或者标签名, 组件接收的参数, 子级)
const jsx1 = <div>Hello React</div>;
const jsx2 = React.createElement('div', null, `Hello React`)  // 等价于 jsx1
```



#### 4. 样式的编写

##### 4.1. 内联样式

JSX 中的内联样式需写成一个对象，而对象也是一个变量，故外层还需要用一个 {} 包裹

```jsx
<div style={{color: 'red'}}>红色</div>
```

##### 4.2. 类名的使用

在 jsx 中定义类名，不能使用class，而是使用className。因为class是JavaScript中的一个保留字。

```jsx
import './test.css';  // 有关 red 类名样式的书写只能在外部，然后在组件内部引入
<div className="red">红色</div>
```

##### 4.3. 解决样式污染问题

为防止各组件样式产生影响，react 使用 css module 的方式实现样式的模块化

创建名为 xxx.module.css 这样的样式文件（ create-react-app 中的约定，与普通 CSS 作区分，会自动对里面用到的类名进行加工处理）

```scss
.red{ color: red; }  // 默认会将 red 类名变成 `文件名_red__hash值`
:global(.red){}  // 取消 webpack 对类名的加工
```

```jsx
import Styles from "./test.module.css";  // 引入时用一个变量接收，可打印出来看看
<div className={Styles.red}>红色</div>
```

好像只能解决类名的问题，解决不了标签样式的污染，使用起来也比较麻烦

所以推荐使用 styled-components 库：https://zhuanlan.zhihu.com/p/445762944

##### 4.4. sass 的使用

npm i sass 之后就可以直接创建 .scss 文件，使用时和 .css 一样，包括模块化



#### 5. 事件

React 元素的事件命名采用小驼峰式，如 onClick 

```jsx
<button onClick={this.fn}>按钮</button>
```

##### 5.1. this 指向问题

```jsx
import React from "react";

export default class LearnEvent2 extends React.Component {
  num = 1;
  add() {
    // 直接作为 onClick 事件的回调函数时 this 并不会指向当前组件实例，而是指向 window ，在严格模式下则为 undefined；所以调用时需使用 bind 改变 this 的指向
    console.log(this);
    this.num++;
  }

  render() {
    console.log(this); // render 函数内的 this 指向当前组件实例，即当前这个类实例
    return (
      <div>
        <button onClick={this.add}>+1</button>  // 默认是 window 调用
        <button onClick={this.add.bind(this)}>+1</button>  // 使用 bind 改变 this 指向
        <button onClick={() => this.add()}>+1</button>  // 在箭头函数里面直接调用方法（推荐）
      </div>
    );
  }
}
```

大括号里若是语句则会直接运行，运行完最终需要是一个函数供事件调用，故不能直接通过 `{this.add(2)}` 这种方式传参，而是需要使用 bind 或箭头函数的方式；==推荐使用箭头函数的形式：`onClick={() => this.add(2)}`==

##### 5.2. 合成事件

像 onClick 这样的就是 React 的合成事件，与之对应的 onclick 这样的就是原生事件

合成事件与原生事件执行顺序：React 的合成事件是挂载在 document 对象上的，当真实 DOM 元素触发事件，冒泡到 document 对象后，才会处理 React 事件；所以会先执行原生事件，再执行 React 事件，最后执行真正直接在 document 上挂载的事件



#### 6. state

state 的主要作用是用于组件保存、控制以及修改自己的状态，算是组件的私有属性

##### 6.1. 定义 state

可在 constructor 中定义 state 属性，或直接在组件中定义 state 属性，本质上就是类中的一个属性

##### 6.2. 修改 state

直接通过 this.state.xxx 的方式修改数据时组件并不会重新渲染，只有通过 setState 函数修改数据时才会触发视图的更新

```jsx
state = {
  num: 1,
  id: 0
};
add() {
  // 函数形式，优势是可以获取原对象以及 props 参数
  this.setState((preState, props) => {
    // 需要返回一个对象，将会与原 state 对象进行合并，也就是说会覆盖原同名属性
    return {
      num: preState.num + 1,
    };
  });
  // 对象形式（常用）
  this.setState({
    id: this.state.id + 1,
  });
}
```

setState 方法是异步的，也就是说在 setState 代码之后并不能拿到最新的数据，要使用最新的数据需使用该函数的第二个参数：

```jsx
this.setState(
  {
    id: this.state.id + 1,
  },
  () => {
    console.log(this.state);
  }
);
```

##### 6.3. 引用类型数据的修改

通过使用扩展符 ... 

```jsx
this.setState({
  arr: [...this.state.arr, "新数据"],
  obj: {
    ...this.state.obj,
    name: "新属性",
  },
});
```

==推荐通过 this.state.arr.push() 等方法直接修改数据，然后再通过 setState 赋值进行视图的渲染== ；但 hooks 组件不行，得通过 `setState([...arr])` 这种方式，即引用地址不能相同



#### 7. 列表渲染

在 react 中一般使用 map 方法对数组进行列表渲染，每一项必须得有 key 

```jsx
<div>
  arr：
  {this.state.arr.map((item, index) => (
    <span key={index}>{item}，</span>
  ))}
</div>
```



