pinia 就是 Vuex 的升级版，相当于 Vuex5 



#### 1. 基本使用

安装：npm i pinia 

新建 stores 文件夹，下建 counter.js 文件

```js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 1
  }),
  getters: {
    doubleCount: (state) => state.count * 2
  },
  actions: {
    addCount(val) {
      this.count += val
    }
  }
})
```

在 main.js 中加载仓库

```js
import { createPinia } from 'pinia'
app.use(createPinia())
```

组件中使用

```vue
<template>
  <div>count: {{ counterStore.count }}</div>
  <div>doubleCount: {{ counterStore.doubleCount }}</div>
  <p><button @click="counterStore.addCount(3)">count++</button></p>
</template>

<script setup>
import { useCounterStore } from '@/stores/counter.js'
const counterStore = useCounterStore()
console.log(counterStore)
</script>
```

##### 1.2. defineStore 风格

defineStore 第二个参数也可以写成函数形式，更灵活

```js
// ref 就是 state ，computed 就是 getters , function 就是 actions
// 猜测会自动区分变量的类型，ref和reactive类型就自动存入$state，其他类似
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }
  return { count, doubleCount, increment }
})
```



#### 2. 状态的修改

可直接修改：`counterStore.count++` ，适合简单修改

通过 actions 修改：`counterStore.addCount(3)` ，可写大量逻辑，包括异步操作，如发送网络请求

仓库数据的解构：`const { count } = storeToRefs(counterStore)`

重置 state ：`counterStore.$reset()`

批量修改 state ：`counterStore.$patch({})` 或者 `counterStore.$patch((state)=>{})` ；比一个个修改在性能上有提升

替换 state ：`counterStore.$state = {}` ；$state 就是整个仓库

监听 state ：`counterStore.$subscribe((mutation, state) => { console.log(mutation, state) })` ；与watch区别，可以拿到旧值，对于 $patch 批量修改只触发一次，且只要调用 $patch 就会触发（无论值是否改变）



#### 3. Pinia 插件

pinia 插件就是一个函数，这个函数将作为参数传给 `pinia.use()` 

##### 3.1. 简单示例

```js
// 在安装此插件后，创建的每个仓库中都会添加一个名为 secret 的属性
function secretPiniaPlugin() {
  return { secret: 'the cake is a lie' }
}

import { createPinia } from 'pinia'
const pinia = createPinia()
pinia.use(secretPiniaPlugin)
```

##### 3.2. 插件的上下文

插件函数可以接收一个参数，即 context ，常解构出 store 进行使用

```js
export function myPiniaPlugin(context) {
  context.pinia // 用 `createPinia()` 创建的 pinia。 
  context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。
  context.store // 每个具体的仓库，如 counterStore 等
  context.options // 获取 defineStore() 时传入的选项，如state, getters, actions等
  // ...
}
```

##### 3.3. 为所有的 store 添加公共属性或方法

可以直接通过在一个插件中返回包含特定属性的对象来为每个 store 都添加上特定属性，如 3.1. 简单示例

也可以直接往 store 上添加：   // 这种方式不会被 devtools 追踪，但可以灵活添加逻辑

```js
export function piniaPlugins({ store }) {
  store.title = "Hello world！";
  store.sayHi = () => { console.log('hi') }
  store.$subscribe(() => { console.log('store被修改') }); // 可以监听所有仓库状态的变化
}
```

##### 3.4. 封装本地存储插件

```js
export const piniaPlugin = (context) => {
  // console.log(context)
  // 判断是否添加了 save 属性且值为true
  if (context.options.save === true) {
    context.store.count = +sessionStorage.getItem('count') || 1
    context.store.$subscribe((mutation, state) => {
      // console.log(mutation, state)
      sessionStorage.setItem('count', state.count)
    })
  }
}
```

可根据 context.store.$state 和 mutation.events.key 等参数继续优化

定义仓库时添加一个选项 save 即可：

```js
export const useCountStore = defineStore('count', {
  state: () => ({
    count: 1,
    name: 'ee'
  }),
  // 为 true 代表保存该仓库的数据，为 false 或不写则不保存
  save: true
})
```

##### 3.5. 第三方持久化插件

使用插件 pinia-plugin-persistedstate ：https://prazdevs.github.io/pinia-plugin-persistedstate/zh/guide/

```js
// 下载
npm i pinia-plugin-persistedstate
//在 main.js 中导入并安装
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
pinia.use(piniaPluginPersistedstate)
// 使用
export const useCounterStore = defineStore('counter', {
    state: () => ({ count: 10, num: 100 }),
		// 每次改变 count 就会将数据自动存储到本地，刷新时也会自动将本地数据赋值给 count 
    persist: true,  // 也可写成一个对象，用于选择存储在 sessionStorage 还是 localStorage 中
}) 
```

对于函数形式则将 persist 放在 defineStore 的第三个参数中

```ts
defineStore('counter', ()=>{}, { persist: true })
```



