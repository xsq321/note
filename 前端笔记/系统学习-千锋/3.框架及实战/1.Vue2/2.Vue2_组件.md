#### 1. 组件通信

##### 1.1. props 传值

父传子时传递普通数据，子传父时传递函数（子组件调用函数时传递参数给父组件；==vue 内部对 methods 中函数的 this 指向进行了修改，不管怎样调用都指向自己组件的 vc ，vc 是组件实例对象的简称==）

通过对象形式可实现 prop 的验证，常用属性为 type, required, default ；[prop验证详细内容](https://v2.cn.vuejs.org/v2/guide/components-props.html#Prop-验证)

子组件在 beforeCreate 生命周期就可以使用 props 了，而 data 需在 created 后开始使用

##### 1.2. 自定义事件

父组件通过 props 传递给子组件的数据，子组件不能修改，但可通过自定义事件由子组件通知父组件修改，同时可传递参数给父组件；代替了使用 props 传递函数给子组件

父组件监听自定义的子组件事件 `<子组件 @事件名='函数名'>` ，子组件通过 `this.$emit('事件名',参数)` 触发

父组件也可以在任何位置通过 `this.$refs.xxx.$on('事件名',函数名)`  监听事件，比 props 更灵活；且自定义事件不需要用 props 接收参数，更方便

##### 1.3. 全局事件总线

```
Vue.prototype.$bus = this	// 配置事件总线，就是把vm挂载到Vue的原型上，使$bus拥有$emit和$on方法
```

组件通过 `this.$bus.$emit('事件名',参数)` 传递参数，通过 `this.$bus.$on('事件名',函数名)` 获取参数

##### 1.4. 组件实例和 Vue 实例

每个组件都是一个 VueComponent 构造函数，每用一次组件标签就会创建一个对应的组件实例对象，其实 Vue 解析组件标签时执行了 new VueComponent(options) 

组件内部的 this 指向当前组件的实例（VueComponent 实例对象）；new Vue 中的this指向的是 Vue 实例对象

==Vue 强制让 VueComponent 的原型对象的隐式原型指向了 Vue 的原型对象，这样组件实例的原型链上就有了 Vue 的原型对象，使得组件实例可以使用 Vue 原型对象上的属性和方法==

```
Vuecomponent.prototype.__proto__ === Vue.prototype
```

##### 1.5. 处理边界

详细内容：https://v2.cn.vuejs.org/v2/guide/components-edge-cases.html

this.$root 可以访问根实例（是 vue 的实例 vm ，就是通过 new Vue 出来的那个 Vue 根实例，而不是根组件 App的实例），this.$parent 可以访问父组件实例，this.$refs.xxx 访问指定子组件实例

##### 1.6. 插槽

在一定程度上也实现了组件通信，详细：[8. slot插槽](F:\github数据（note仓库）\前端笔记\基础学习\前端基础\3.vue\3.Vue脚手架.md)



#### 2. 高级组件

##### 2.1. 动态组件

代替了使用 v-if 实现组件的切换，效果和 v-if 相同但代码更简练，用一行代替了多行

```vue
<component :is='要加载的组件名称'></component>
```

##### 2.2. 缓存组件

用 keep-alive 包裹起来，会将已渲染过的组件（已显示、已点击过的组件）缓存到内存中，即不销毁组件，需要的时候直接读取缓存而不需要重新渲染；默认全缓存，但可选择，且可使用正则

```vue
<keep-alive :include="['Animal']" :exclude="['Person']"></keep-alive>
```

==当组件在 `<keep-alive>` 内被切换时，会执行 `activated` 和 `deactivated` 这两个特有的生命周期钩子函数，分别为组件被激活时触发和组件失活时触发， `<keep-alive>` 树内的所有嵌套组件中都有，可监听组件的切换==

##### 2.3. 异步组件

Vue 只有在这个组件需要被渲染时才从服务器加载，且会把结果缓存起来供未来重新渲染；可以加快首页的加载

```js
Person:()=>import('./Person.vue') //可直接写在components里
```

##### 2.4. errorCaptured

在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。

```js
errorCaptured(err, vm, info){ return false }
```



#### 3. 过渡与动画

详细内容：https://v2.cn.vuejs.org/v2/guide/transitions.html

用 `<transition name="slide"></transition>` 包裹，然后用以下六个类名控制效果，v 用对应 name 替换

v-enter, v-enter-to, v-enter-active 分别代表进入之前，进入之后，进入的效果（既可以是过渡也可以是动画）

v-leave, v-leave-to, v-leave-active 和进入相反，注意 v-leave 和 v-enter-to 是相同的

使用第三方集成库 animate.css（https://animate.style/）配合 transition 一起使用：

```vue
    <transition
      name="fade"
      enter-active-class="animate__animated animate__bounceInDown"
      leave-active-class="animate__animated animate__bounceOutDown"
    >
      <div v-show="isShow2">内容部分</div>
    </transition>
```



#### 4. 组件通信其他方式

##### 4.1. 依赖注入（provide/inject）

允许组件向后代组件直接传递参数，https://v2.cn.vuejs.org/v2/guide/components-edge-cases.html

```js
祖先组件：provide: function(){ return { getMap: this.getMap } }
后代组件：inject: ['getMap']
```

可以看作是大范围有效的  prop ，只是祖先组件不知道提供给了哪些后代组件，后代组件也不知道是谁提供的，且传递的数据是非响应式的

##### 4.2. .sync 属性修饰符

可实现父子组件数据的双向绑定，其实就是在 prop 传值的基础上多传了一个自定义方法；是一个语法糖

```vue
父组件：<Son :title.sync="doc.title"></Son>
子组件：通过 this.$emit('update:title', newTitle) 通知父组件修改数据
父组件完整写法：<Son :title="doc.title" @update:title="doc.title = $event" ></Son>
```

类似的还有：`<Son v-model:title="doc.title">` ，也是个语法糖，实现的效果和 .sync 相同；注意 v-model 在 input 标签和在组件标签上实现的语法糖不同（监听的事件不同，一个是 @input ，一个是 @update:title ）

##### 4.3. $attrs 和 $listeners

this.$attrs ：收集父组件向子组件传递的所有属性（除 class, style 和已经被 props 接收的），是个对象并且可通过 `v-bind="$attrs"` 直接传入内部组件

this.$listeners ：收集父组件通过 @ 向子组件传递的所有方法，也可以通过 `v-on="$listeners"` 传入内部组件

在创建高级别的组件时非常有用，因为需要传递特别多的属性与方法（事件）

inheritAttrs 选项（和 data, methods 等同级）为 false 时可以去除那些未被 props 接收的属性（禁用 Attributes 继承），默认为 true 时这些属性会作为 html 属性应用在子组件的根元素上





